## 对象的创建与销毁
### 1、用静态工厂方法代替构造器
- 静态工厂方法与构造器不同的第一大优势在于，它们有名称
- 静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。
- 静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。
- 静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。只要是已声明的返回类型的子类型，都是允许的。
- 静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。
- 静态工厂方法的主要缺点在于，类如果不含公有的或者受保护的构造器，就不能被子类化。
- 静态工厂方法的第二个缺点在于，程序员很难发现它们。
#### 静态工厂方法的一些惯用名称：
- from一一类型转换方法，它只有单个参数，返回该类型的一个相对应的实例，例如：
  Date d= Date.from(instant) ;
- of 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来，例如：
  Set<Rank> faceCards = EnumSet.of(JACK , QUEEN, KING);
- valueOf一一比from 和of 更烦琐的一种替代方法，例如：
  BigInteger  primer = BigInteger.valueOf(Integer.MAX_VALUE);
- instance 或者getInstance一－返回的实例是通过方法的（如有）参数来描述的，但是不能说与参数具有同样的值，例如：
  StackWalke 「luke = StackWalke 「.getinstance(options);
- create 或者newInstance一一像instance 或者getInstance 一样，但create或者newInstance 能够确保每次调用都返回一个新的实例，例如：
  Object newArray = Aarray.newInstance(classObject, arraylen);
- getType-一像getInstance 一样，但是在工厂方法处于不同的类中的时－候使用。Type 表示工厂方法所返回的对象类型，例如：
  FileStore fs = Files.getFileStore(path];
- newType一像Instance 一样，但是在工厂方法处于不同的类中的时候使用。。
- Type 表示工厂方法所返回的对象类型，例如：
  BufferedReader br＝ Files.newBufferedReader(path);
- type-一－getType 和newType 的简版，例如：
  List<Complaint> litany ＝ Collections.list(legacylitany 〕；
### 2、遇到多个构造器参数时要考虑使用构建器（builder模式）
- 常规builder模式，每个类定义一个static Builder类
- lombok 注解@builder模式
- jdk8 builder模式
### 3、用私有构造器或者枚举类型强化Singleton 属性
### 4、通过私有构造器强化不可实例化的能力
  企图通过将类做成抽象类来强制该类不可被实例化是行不通的。让这个类包含一个私有构造器，它就不能被实例化
### 5、优先考虑依赖注入来引用资源
- 当创建一个新的实例时， 就将该资源传到构造器中。
- 将资源工厂（ factory ）传给构造器，在Java 8 中增加的接口Supplier<T>，最适合用于表示工厂.
### 6、避免创建不必要的对象
- 对于同时提供了静态工厂方法（ static factory method) （详见第l 条）和构造器的不可变类，通常优先使用静态工厂方法而不是构造器，以避免创建不必要的对象。
- 要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。
- 通过维护自己的对象池（ object pool ）来避免创建对象并不是一种好的做法，除非池中的对象是非常重量级的（比如数据库连接池）
- 在提倡使用保护性拷贝的时候，因重用对象而付出的代价要远远大于因创建重复对象而付出的代价
### 7、消除过期的对象引用
- 一般来说， 只要类是自己管理内存，程序员就应该警惕内存泄漏问题。一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。
- 内存泄漏的另一个常见来源是缓存。一旦你把对象引用放到缓存中，它就很容易被遗忘掉，从而使得它不再有用之后很长一段时间内仍然留在缓存中。
- 内存泄漏的第三个常见来源是监昕器和其他回调，确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用（ weak reference ） ，例如，只将它们保存成WeakHashMap 中的键。
### 8、避免使用终结方法和清除方法
- 终结方法（ finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。
- 在Java 9中用清除方法（ cleaner ）代替了终结方法。清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢，一般情况下也是不必要的。  
- 终结方法和清除方法的缺点在于不能保证会被及时执行，因此注重时间(time-critical) 的任务不应该由终结方法或者清除方法来完成。
- 使用终结方法和清除方法有一个非常严重的性能损失。
- 终结方法有一个严重的安全问题： 如果从构造器或者它的序列化对等体（ readObject和readResolve 方法，详见第12 章）抛出异常，恶意子类的终结方法就可以在构造了一部分的应该已经半途夭折的对象上运行。为了防止 
  非final 类受到终结方法攻击， 要编写一个空的final 的finalize 方法。
- 第一种用途是，当资源的所有者忘记调用它的close 方法时，终结方法或者清除方法可以充当“安全网”
### 9、try-with-resources 优先于try-finally （相对应的资源需要实现AutoCloseable）
## 对于所有对象都通用的方法
### 10、覆盖equals 时请遵守通用约定
  #### 无需提供equal覆盖的条件：
  - 类的每个实例本质上都是唯一的
  - 类没有必要提供“逻辑相等”（ logical equality ）的测试功能
  - 超类已经覆盖了equals ， 超类的行为对于这个类也是合适的。
  - 类是私有的， 或者是包级私有的， 可以确定它的equals方法永远不会被调用。如果你非常想要规避风险，可以覆盖equals 方法，以确保它不会被意外调用（通过覆盖方法抛出异常）
  #### 应该覆盖equals的条件：类具有自己特有的“逻辑相等”（ logical equality ）概念（不同于对象等同的概念），而且超类还没有覆盖equals
  #### equals 通用约定，equals 方法实现了等价关系（ equi va lence relation ）
  - 自反性（ reflexive ）：对于任何非null 的引用值x， x.equals(x)必须返回true 。
  - 对称性（ symmetric ）：对于任何非null 的引用值x 和y ，当且仅当y.equals(x)返回true 时， x.equals(y)必须返回true 。
  - 传递性（ transitive ） ： 对于任何非null 的引用值x 、y 和z ，如果x.equals(y)返回true ，并且y.equals(z)也返回true ，那么x.equals(z)也必须返回true。
  - 一致性（ consistent ） ： 对于任何非null 的引用值x 和y ，只要equals 的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true,或者一致地返回false 。
  - 对于任何非null 的引用值x, x.equals (null ）必须返回false 。
 #### equals高质量实现
  - 使用＝＝操作符检查“参数是否为这个对象的引用”
  - 使用instanceof 操作符检查“参数是否为正确的类型”
  - 把参数转换成正确的类型。
  - 对于该类中的每个“关键”（ significant ）域，检查参数中的域是否与该对象中对应的域相匹配。
 #### 覆盖equals方法的一些告诫
  - 覆盖equals 时总要覆盖hashCode
  - 不要企图让equals 方法过于智能。
  - 不要将equals 声明中的Object 对象替换为其他的类型。
### 11、覆盖equals 时总要覆盖hashCode
  - 在应用程序的执行期间，只要对象的equals 方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用， hashCode 方法都必须始终返回同一个值。在一个应用程序与另一个程序的执行过程中，执行        hashCode方法所返回的值可以不一致。
  - 如果两个对象根据equals(Object ）方法比较是相等的，那么调用这两个对象中的hashCode 方法都必须产生同样的整数结果。
  - 如果两个对象根据equals(Object ）方法比较是不相等的，那么调用这两个对象中的hashCode 方法，则不一定要求hashCode 方法必须产生不同的结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结     果，有可能提高散列表（ hashtable ）的性能。
### 12、始终要覆盖toString
### 13、谨慎地覆盖clone
### 14、考虑实现Comparable 接口
  - 实现者必须确保所有的x 和y 都满足sgn(x.compareTo(y) ) == - sgn (y.compareTo (x)) 。（这也暗示着，当且仅当y.compareTo (x)抛出异常时， x.compareTo(y)才必须抛出异常。)
  - 实现者还必须确保这个比较关系是可传递的： （x.compareTo ( y) > 0 & & y.compareTo(z) > 0 ）暗示着x.compareTo (z) > 0 。
  - 最后，实现者必须确保x. compareTo ( y) == 0 暗示着所有的z 都满足sgn(x.compareTo ( z) ) == sgn ( y.compare To ( z) ） 。
  - 强烈建议(x . compare To (y) == 0) == (x . equals (y ))，但这并非绝对必要。一般说来，任何实现了Comparable 接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意：具         有内在的排序功能，但是与equals 不一致。”
## 类和接口
### 15、使类和成员的可访问性最小化
### 16、要在公有类而非公有域中使用访问方法
### 17、使可变性最小化（不可变类）
  - 不要提供任何会修改对象状态的方法
  - 保证类不会被扩展
  - 声明所有的域都是final 的
  - 声明所有的域都为私有的
  - 确保对子任何可变组件的互斥访问
### 18、复合优先于继承
   继承打破了封装性，子类必须要跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文挡说明。解决方案是不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例
### 19、要么设计继承并提供文档说明，要么禁止继承
  - 对于设计用于继承的类来说，该类必须在文档中说明，在哪些情况下它会调用可重写的方法。如果方法调用到了可覆盖的方法，在它的文档注释的末尾应该包含关于这些调用的描述信息（Javadoc 标签@implSpec）
  - 类必须以精心挑选的受保护的（ protected ）方法的形式，提供适当的钩子（ hook ），以便进入其内部工作中
  - 对于为了继承而设计的类，唯一的测试方法就是编写子类。如果编写了多个子类，并且未使用受保护的成员，或许就应该将该成员设置成私有的。通常3个子类可以测试一个可扩展的类
  - 构造函数绝不能调用可被重写的方法，可以调用私有方法、final 方法和静态方法
  - 如果设计的类实现Cloneable 或者Serializable 接口，无论是clone 还是readObject ， 都不可以调用可覆盖的方法，不管是以直接还是间接的方式
  - 对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化（final类或者构造方法私有化）
### 20、接口优于抽象类
### 21、为后代设计接口（通过缺省方法来更新接口）
### 22、接口只用于定义类型
  - 常量接口模式是对接口的不良使用（用枚举或者不可实例化的工具类替代）
  - 通过利用静态导入（ static import)机制，避免用常量类类名来修饰常量名
### 23、类层次优于标签类
### 24、静态成员类优于非静态成员类
### 25、限制源文件为单个顶级类
## 泛型
### 26、请不要使用原生类型（raw type）
  使用原生类型，就失掉了泛型在安全性和描述性方面的所有优势
### 27、消除未受检查的警告
  - 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下）才可以用一个@SuppressWarnings ("unchecked" ）注解来禁止这条警告
  - 每当使用SuppressWarnings ("unchecked" ）注解时，都要添加一条注释，说明为什么这么做是安全的
  - 应该始终在尽可能小的范围内使用SuppressWarnings 注解。
### 28、列表优于数组
### 29、优先考虑泛型
### 30、优先考虑泛型方法
### 31、利用有限制通配符来提升API 的灵活性
  - PECS 表示producer-extends, consumer-super
  - comparable 和comparator 都是消费者
### 32、谨慎并用泛型和可变参数
  - 将值保存在泛型可变参数数组参数中是不安全的
  - 允许另一个方法访问一个泛型可变参数数组是不安全的
  - 对于每一个带有泛型可变参数或者参数化类型的方法，都要用@SafeVarargs 进行注解
  - 泛型可变参数方法在下列条件下是安全的：
    - 1. 它没有在可变参数数组中保存任何值。
    - 2. 它没有对不被信任的代码开放该数组（或者其克隆程序） 。
### 33、优先考虑类型安全的异构容器
## 枚举和注解
### 34、用enum代替int常量
### 35、用实例域代替序数
  永远不要根据枚举的序数导出与它关联的值， 而是要将它保存在一个实例域中
### 36、用EnumSet 代替位域
### 37、用EnumMap 代替序数索引
### 38、用接口模拟可扩展的枚举
### 39、注解优先于命名模式
### 40、坚持使用Override 注解
### 41、用标记接口定义类型
  - 标记接口定义的类型是由被标记类的实例实现的；标记注解则没有定义这样的类型
  - 标记接口胜过标记注解的另一个优点是，它们可以被更加精确地进行锁定
  - 如果标记是应用于任何程序元素而不是类或者接口，就必须使用注解，因为只有类和接口可以用来实现或者扩展接口
## Lambda和Stream
### 42、lambda 优先于匿名类
### 43、方法引用优先于Lambda（哪个代码更简洁用哪个）
### 44、坚持使用标准的函数接口
  Operator 接口代表其结果与参数类型一致的函数。Predicate 接口代表带有一个参数并返回一个boolean 的函数。Function 接口代表其参数与返回的类型不一致的函数。Supplier 接口代表没有参数并且返回（或“提   供”）一个值的函数。最后， Consumer 代表的是带有一个函数但不返回任何值的函数，相当于消费掉了其参数。
### 45、谨慎使用Stream
### 46、优先选择Stream 中无副作用的函数
### 47、Stream 要优先用Collection 作为返回类型  
### 48、谨慎使用Stream 并行
  - 在Stream 上通过并行获得的性能， 最好是通过ArrayList 、HashMap 、HashSet和ConcurrentHashMap 实例，数组， int 范围和long 范围等
  - 并行Stream 不仅可能降低性能，包括活性失败，还可能导致结果出错，以及难以预计的行为
## 方法
### 49、检查参数的有效性
  - Objects.requireNonNull
  - Assert
### 50、必要时进行保护性拷贝
  - 保护性拷贝是在检查参数的有效性（详见第49 条）之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。
  - 对于参数类型可以被不可信任方子类化的参数，请不要使用clone 方法进行保护性拷贝。
### 51、谨慎设计方法签名
  - 谨慎地选择方法的名称
  - 不要过于追求提供便利的方法
  - 避免过长的参数列表
  - 对于参数类型，要优先使用接口而不是类
  - 对于boolean 参数，要优先使用两个元素的枚举类型
### 52、慎用重载
### 53、慎用可变参数
### 54、返回零长度的数组或者集合，而不是null
### 55、谨慎返回optinal
  - 容器类型包括集合、映射、Stream 、数组和optional ，都不应该被包装在optional 中
  - 如果无法返回结果并且当没有返回结果时客户端必须执行特殊的处理，那么就应该声明该方法返回Optional<T>
### 56、为所有导出的API 元素编写文档注释
## 通用编程
### 57、将局部变量的作用域最小化
### 58、for-each 循环优先于传统的for 循环
  无法使用for-each的三种情况：
  - 解构过滤一一如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的remove 方法。使用Java 8 中增加的Collection 的removeIf方法，常常可以避免显式的遍历
  - 转换一一如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。
  - 平行迭代一一如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进。
### 59、了解和使用类库
  - 在每个重要的发行版本中，都会有许多新的特性被加入到类库中，所以与这些新特性保持同步是值得的
  - 每个程序员都应该熟悉java.lang、java.util、java.io 及其子包中的内容
  - Collections Framework （集合框架）和Stream 类库（详见第45条至第48 条）应该成为每一位程序员基本工具箱中的一部分，同样也应该成为java.util.concurrent中并发机制的组成部分
  - 如果你在Java 类库中找不到所需要的功能，下一个选择应该是在高级的第三方类库中去寻找，比如Google 优秀的开源Guava 类库［ Guava ］ 。
### 60、如果需要精确的答案，请避免使用float 和double
### 61、基本类型优先于装箱基本类型
### 62、如果其他类型更适合，则尽量避免使用字符串
  - 字符串不适合代替其他的值类型
  - 字符串不适合代替枚举类型
  - 字符串不适合代替聚合类型
### 63、了解字符串连接的性能（不要使用字符串连接操作符来合并多个字符串）
### 64、通过接口引用对象
  - 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明
  - 如果养成了用接口作为类型的习惯，程序将会更加灵活（方便更换实现类）
### 65、接口优先于反射机制
### 66、谨慎地使用本地方法
### 67、谨慎地进行优化
  - 要努力编写好的程序而不是快的程序
  - 要努力避免那些限制性能的设计决策
  - 要考虑API 设计决策的性能后果 
  - 为获得好的性能而对API 进行包装，这是一种非常不好的想法
  - 在每次试图做优化之前和之后，要对性能进行测量
### 68、遵守普遍接受的命名惯例
## 异常
### 69、只针对异常的情况才使用异常
### 70、对可恢复的情况使用受检异常，对编程错误使用运行时异常
  - 对于可恢复的情况，要抛出受检异常
  - 对于程序错误，要抛出运行时异常
  - 不确定是否可恢复，则抛出未受检异常
### 71、避免不必要地使用受检异常
### 72、优先使用标准的异常
  - 不要直接重用Exception 、RuntimeException , Throwable 或者Error
  - 如果没有可用的参数值，就抛出IllegalStateExceptio凡否则就抛出IlegalArgumentException
### 73、抛出与抽象对应的异常
 - 更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常(异常转译)
 - 如果不能阻止或者处理来自更低层的异常，一般的做法是使用异常转译，只有在低层方法的规范碰巧可以保证“它所抛出的所有异常对于更高层也是合适的”情况下，才可以将异常从低层传播到高层　
### 74、每个方法抛出的所有异常都要建立文档
  - 始终要单独地声明受检异常， 并且利用Javadoc 的@throws 标签， 准确地记录下抛出每个异常的条件
  - 使用Javadoc 的@throws 标签记录下一个方法可能抛出的每个未受检异常，但是不要使用throws 关键字将未受检的异常包含在方法的声明中
  - 如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，这是可以接受的
### 75、在细节消息中包含失败一捕获信息
  - 为了捕获失败，异常的细节信息应该包含“对该异常有贡献”的所有参数和域的值。
  - 千万不要在细节消息中包含密码、密钥以及类似的信息
### 76、努力使失败保持原子性
  - 一般而言，失败的方法调用应该使对象保持在被调用之前的状态
### 77、不要忽略异常
  - 空的catch 块会使异常达不到应有的目的
  - 如果选择忽略异常， catch 块中应该包含一条注释，说明为什么可以这么做，并且变量应该命名为ignored
## 并发
### 78、同步访问共享的可变数据
  - 为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的
  - 千万不要使用Thread.stop 方法,建议线程采用轮询获取访问锁
  - 除非读和写操作都被同步，否则无法保证同步能起作用
  - 将可变数据限制在单个线程中
  - 当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步
### 79、避免过度同步
  - 为了避免活性失败和安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对害户端的控制
  - 通常来说，应该在同步区域内做尽可能少的工作
### 80、executor 、task 和stream 优先于线程
### 81、并发工具优先于wait 和notify
  - 并发集合中不可能排除并发活动；将它锁定没有什么作用，只会使程序的速度变慢
  - 应该优先使用ConcurrentHashMap ，而不是使用Collections.synchronizedMap
  - 对于间歇式的定时，始终应该优先使用System.nanoTime ，而不是使用System.currentTimeMillis。因为System.nanoTime 更准确，也更精确，它不受系统的实时时钟的调整所影响
  - 始终应该使用wait 循环模式来调用wait 方法；永远不要在循环之外调用wait 方法
### 82、线程安全性的文档化
### 83、慎用延迟初始化
### 84、不要依赖于线程调度器
  - 任何依赖于线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的
  - 如果线程没有在做有意义的工作，就不应该运行
  - 线程优先级是Java 平台上最不可移植的特征
## 序列化
### 85、其他方法优先于Java 序列化
  序列化是很危险的，应该予以避免。如果是重新设计一个系统，一定要用跨平台的结构化数据表示法代替，如JSON 或者protobuf。不要反序列化不被信任的数据
### 86、谨慎地实现Serializable 接口
  - －旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性
  - 它增加了出现Bug 和安全漏洞的可能性
  - 随着类发行新的版本，相关的测试负担也会增加
  - 为了继承而设计的类（详见第19 条）应该尽可能少地去实现Serializable 接口，用户的接口也应该尽可能少继承Serializable 接口
### 87、考虑使用自定义的序列化形式
### 88、保护性地编写readObject 方法
  - 对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别
  - 对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException 异常。这些检查动作应该跟在所有的保护性拷贝之后
  - 如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectinputValidation接口
  - 无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法
### 89、对于实例控制，枚举类型优先于readResolve
### 90、考虑用序列化代理代替序列化实例
